## JAVA内存模型——JMM ##
内存模型是一种用于管理和控制多线程之间共享变量可见性的一种模型，定义了主内存与工作内存之间的协调运作方式。

重排序是程序编译和执行过程中为了提高性能必然会发生的情况，而内存模型则针对这种情况进行了定义，在什么样的情况下可以允许重排序，哪些场景不允许。

重排序一般有三种情况，一种是基于编译器的重排序，这种重排序在保证不改变代码的单线程语义的前提下可以对代码进行重排序；还有一种是基于指令级并行的重排序，这种排序，如果不存在数据依赖性，处理器可以对代码执行顺序进行调整；最后一种重排序则是内存系统的重排序。

内存模型会规定哪些场景下不允许进行重排序，当出现这种场景时就会在编译器生成代码指令时适时地插入内存屏障，确保在后续的指令级并行重排序和内存重排序中出现执行顺序的问题。

内存模型最终展示给程序员的就是一个happens-before语义，代码开发过程中主要能理解和正确使用这个语义代码的多线程并发就没有问题。

## happens-before ##
happens-before是一种程序员可读的一种规则，它底层规定了那些操作必须要在happens-before另外一些操作之前，因此，是一种内存模型对于重排序规则的提现。

具体来说则是有如下几种场景：

- 程序顺序规则：一个线程中的每个操作，happensbefore 于该线程中的任意后续操作。
- 监视器锁规则：对一个监视器锁的解锁，happensbefore 于随后对这个监视器锁的加锁。
- volatile变量规则：对一个volatile域的写，happensbefore 于任意后续对这个volatile域的读。
- 传递性：如果A happensbefore B，且B happensbefore C，那么A happensbefore C。

比较常见的就是volatile关键字，这关键字的特点就在于一旦它修饰的变量被修改了，那么后续所有读取该变量的地方都可以读取到最新的值。
