# TCP慢启动，拥塞避免，快速恢复和快速重传 #
在局域网内，TCP的客户端和服务端的网络链路较为稳定，并且传输速录也很高，可以在传输开始时就传输多个报文段，并根据报文的相应结果进行相应调整。但是对于经过多个路由器或者链路不稳定时则需要对可发送的报文书进行探测，否则可能会导致本来就不稳定的网络发生更严重的拥塞。

## TCP慢启动 ##
TCP慢启动就是在这种条件下应运而生的。
当网络状态不明确的时候不能直接发送较大的报文，而是进行探测发送。慢启动算法是通过观察报文的发送速率应该与响应速率是否相同进行工作的。换句话说就是通过发送报文速率与响应速率大小关系的反馈进行调整并最终确定发送窗口大小的。这种方式可以防止一次性过大的报文发送加重网络拥塞，也可以尽可能的使用网络带宽。

慢启动算法中给发送方增加了一个拥塞窗口的定义——cwnd，该窗口在连接建立的时候初始化为1个对端MSS的大小，每当收到对端的一个ACK后就将该窗口大小翻倍，最终当报文数达到链路的承载上限以后就会出现丢包现象。发送方接收不到ACK后就认为当前网络已经饱和，不能继续增加cwnd的大小了。

当发送方使用慢启动算法达到网络承载上限后需要拥塞避免算法处理丢弃的分组。
### 慢启动算法 ###
拥塞避免算法除了需要指定拥塞窗口以外还需要制定一个慢启动门限ssthresh，算法如下：


- 连接初始化的时候制定cwnd为一个MSS的大小，并且制定ssthresh为65535个字节。


- TCP传输过程中不能超过cwnd和接收方接收窗口的大小。


- 当拥塞发生时（超市或者收到重复的ACK），ssthresh设置为当前窗口大小的一半（至少要大于等于两个报文段大小）。如果是超时引起的拥塞，则同时将cwnd减为1。



- 当接收到ACK时就增加cwnd的大小，具体增加的大小根据当前状态判断，如果当前的cwnd<ssthresh的话就是慢启动状态，如果cwnd>=ssthresh的话就是拥塞避免状态。


- 如果是慢启动状态则进行指数型增加，如果是拥塞避免状态则进行加法式增加，每接收到一个ACK就在cwnd上加一。
### TCP慢启动及拥塞避免算法示例 ###
假设当前网络的承载能力是20个报文大小，则慢启动和拥塞避免的算法下报文数的正常情况如下：

![慢启动和拥塞避免算法](https://github.com/lichong/Resource/blob/master/%E6%85%A2%E5%90%AF%E5%8A%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E.png?raw=true)

## 快速恢复和快速重传 ##

慢启动和拥塞避免算法可以确保网络代码的有效使用，但是一旦出现超时拥塞的时候，cwnd就会从1开始重新探测。除了这种场景的数据丢失外还有一种是出现了重复的ACK，比如发送发发送了1,2,3,4,5几个报文，但是接受方只接收到了1,2,3,5，此时客户端发送报文后就会收到服务端重复的ACK3，表示服务端只收到报文3，后续的报文要么是乱序要么是还没收到，当该发送方收到三次重复的ACK后就可以认为当前报文有丢失，可以立即启动重传，而不用等待超时——此即为快速重传。接下来就可以执行快速恢复而不是慢启动流程了。

这种情况下没有执行慢启动而是快速恢复是因为收到的重复的ACK，这就说明在接收方是可以正常接收数据流的，只是因为乱序或者报文丢失而返回了重复的ACK，在这种场景下没有必要重启慢启动算法。

### 快速恢复算法 ###



- 当收到三个重复的ACK以后，将ssthresh的大小设置为当前窗口的一半，重传丢失报文，另外设置cwnd为ssthresh+3个报文段，加三个报文段是因为当前已经有三个重复的ACK，也就是网络中至少有三个包已经被丢弃了。


- 每次收到一个重复的ACK后就将cwnd+1，并发送一个分组


- 当收到新数据的ACK以后把cwnd设置为第一步的ssthresh大小，表明当前的丢失报文已经传输完毕，重新开始拥塞避免算法。

示例图如下：

![快速恢复算法](https://github.com/lichong/Resource/blob/master/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.png?raw=true)
